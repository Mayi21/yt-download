# 64KB 缓冲区工作原理

## 🔍 实际工作流程

### 1. 写入流程
```
用户调用 logger.info("消息") 
    ↓
立即写入到 64KB 内存缓冲区
    ↓
根据条件决定是否刷新到磁盘
```

### 2. 刷新触发条件

#### ✅ 立即刷新（ERROR级别）
```rust
if level >= LogLevel::Error {
    let _ = inner.writer.flush();  // 立即写入磁盘
}
```

#### ✅ 自动刷新（BufWriter内部逻辑）
- 缓冲区接近满时（通常是64KB的80-90%）
- 程序正常退出时
- 显式调用 flush() 时

#### ✅ 其他刷新时机
- 日志轮转时
- 程序崩溃时（Drop trait）

## 📊 性能对比

### 无缓冲区（每次都写磁盘）
```
写入1条日志 → 磁盘I/O（慢）
写入2条日志 → 磁盘I/O（慢）
写入3条日志 → 磁盘I/O（慢）
...
```

### 有缓冲区（批量写入）
```
写入1条日志 → 内存缓冲区（快）
写入2条日志 → 内存缓冲区（快）
写入3条日志 → 内存缓冲区（快）
...
写入N条日志 → 达到条件，批量写入磁盘
```

## 🎯 实际效果

### 普通日志（INFO/DEBUG）
- 写入内存缓冲区（微秒级）
- 积累到一定量后批量写入磁盘
- 大幅提升性能

### 错误日志（ERROR）
- 写入内存缓冲区
- **立即刷新到磁盘**（确保错误不丢失）
- 牺牲一点性能换取可靠性

## 🔧 缓冲区大小选择

### 为什么是64KB？
- **太小**（如4KB）：频繁刷新，性能提升有限
- **太大**（如1MB）：内存占用高，程序崩溃时丢失更多日志
- **64KB**：平衡性能和可靠性的最佳选择

### 实际容量
64KB ≈ 可存储约 1000-2000 条普通日志消息